{% block content %}
<div class="col-12">
    <div class="card">
        <div class="filter">
            <style>
                .btn-outline-primary {
                    margin-right: 30px;
                }
                #reportsChart2.fullscreen {
                    background: white;
                    padding: 20px;
                    height: 100vh;
                    width: 100vw;
                }
                
                #chartContainer2.fullscreen {
                    background: white;
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    z-index: 9999;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                }
                
                #chartContainer2 {
                    width: 100%;
                    min-height: 350px;
                    position: relative;
                }

                #fullscreenBtn2 {
                    display: none;
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    z-index: 1000;
                    width: 40px;
                    height: 40px;
                    border-radius: 50%;
                    background: white;
                    border: 1px solid #dee2e6;
                    align-items: center;
                    justify-content: center;
                    padding: 0;
                    transition: all 0.2s;
                }

                #fullscreenBtn2:hover {
                    background: #f8f9fa;
                    transform: scale(1.1);
                }

                #closeFullscreenBtn2 {
                    display: none;
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 10000;
                    background: white;
                    border: 1px solid #dee2e6;
                    border-radius: 50%;
                    width: 40px;
                    height: 40px;
                    cursor: pointer;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.2s;
                }

                #closeFullscreenBtn2:hover {
                    background: #f8f9fa;
                    transform: scale(1.1);
                }

                #chartContainer2.fullscreen #closeFullscreenBtn2 {
                    display: flex;
                }

                @media screen and (max-width: 767px) {
                    #fullscreenBtn2 {
                        display: flex;
                    }
                }
            </style>
            <a class="btn btn-outline-primary" id="weekday" href="#" data-bs-toggle="dropdown">Wybierz dzień tygodnia</a>
            <script>
                const weekdayElement = document.getElementById("weekday");
                if (window.innerWidth <= 768) {
                    weekdayElement.innerHTML = '<i class="bi bi-three-dots"></i>';
                } else {
                    weekdayElement.innerHTML = 'Wybierz dzień tygodnia';
                }
            </script>
            <ul class="dropdown-menu dropdown-menu-end dropdown-menu-arrow">
                <li class="dropdown-header text-start">
                </li>
                <li><a class="dropdown-item" id="stats0">Poniedziałek</a></li>
                <li><a class="dropdown-item" id="stats1">Wtorek</a></li>
                <li><a class="dropdown-item" id="stats2">Środa</a></li>
                <li><a class="dropdown-item" id="stats3">Czwartek</a></li>
                <li><a class="dropdown-item" id="stats4">Piątek</a></li>
                <li><a class="dropdown-item" id="stats5">Sobota</a></li>
                <li><a class="dropdown-item" id="stats6">Niedziela</a></li>
            </ul>
        </div>

        <div class="card-body">
            <h5 class="card-title">Średnia zajętość obiektów (ostatnie 14 dni) <span id="today"> {{today}}</span></h5>

            <div id="chartContainer2">
                <button id="fullscreenBtn2" class="btn btn-sm">
                    <i class="bi bi-arrows-fullscreen"></i>
                </button>
                <button id="closeFullscreenBtn2">
                    <i class="bi bi-x-lg"></i>
                </button>
                <div id="loadingOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; align-items: center; justify-content: center; z-index: 1000;" class="chart-loading-overlay">
                      <div class="d-flex justify-content-center">
                        <div class="spinner-border" role="status">
                          <span class="visually-hidden">Loading...</span>
                        </div>
                      </div>
                </div>
                <div id="reportsChart2" style="position: relative;">

                </div>
            </div>

            <script>
                document.addEventListener("DOMContentLoaded", () => {
                    const chartElement2 = document.querySelector("#reportsChart2");
                    const chartContainer2 = document.querySelector("#chartContainer2");
                    const fullscreenBtn2 = document.querySelector("#fullscreenBtn2");
                    const closeFullscreenBtn2 = document.querySelector("#closeFullscreenBtn2");
                    const FULLSCREEN_PADDING = 40;
                    const orientationPreferences = {
                        landscape: ['landscape-primary', 'landscape', 'landscape-secondary'],
                        portrait: ['portrait-primary', 'portrait', 'portrait-secondary']
                    };

                    const delay = (ms = 0) => new Promise((resolve) => setTimeout(resolve, ms));
                    const getFullscreenElement = () => document.fullscreenElement || document.webkitFullscreenElement || null;
                    const canUseNativeFullscreen = (element) => Boolean(
                        element.requestFullscreen ||
                        element.webkitRequestFullscreen ||
                        element.webkitRequestFullScreen
                    );

                    const requestElementFullscreen = async (element) => {
                        if (element.requestFullscreen) {
                            return element.requestFullscreen();
                        }
                        const webkitRequest = element.webkitRequestFullscreen || element.webkitRequestFullScreen;
                        if (webkitRequest) {
                            webkitRequest.call(element);
                            return Promise.resolve();
                        }
                        throw new Error('Fullscreen API not supported');
                    };

                    const exitElementFullscreen = () => {
                        if (document.exitFullscreen) {
                            return document.exitFullscreen();
                        }
                        const webkitExit = document.webkitExitFullscreen || document.webkitCancelFullScreen;
                        if (webkitExit) {
                            webkitExit.call(document);
                        }
                        return Promise.resolve();
                    };

                    let chart2;
                    let isFallbackFullscreen = false;
                    let orientationLocked = false;

                    const tryLockOrientation = async (preferences = []) => {
                        if (!screen.orientation || !screen.orientation.lock) {
                            return false;
                        }
                        for (const orientation of preferences) {
                            try {
                                await screen.orientation.lock(orientation);
                                return true;
                            } catch (error) {
                                console.warn(`Orientation lock failed for ${orientation}`, error);
                            }
                        }
                        return false;
                    };

                    const unlockOrientation = () => {
                        if (screen.orientation && screen.orientation.unlock) {
                            try {
                                screen.orientation.unlock();
                            } catch (error) {
                                console.warn("Orientation unlock failed", error);
                            }
                        }
                    };

                    const restorePortraitOrientation = () => {
                        tryLockOrientation(orientationPreferences.portrait).then((locked) => {
                            if (locked && screen.orientation) {
                                let originalOnChange = null;

                                function detachOrientationListeners() {
                                    if (typeof screen.orientation.removeEventListener === 'function') {
                                        screen.orientation.removeEventListener('change', handleOrientationChange);
                                    } else if ('onchange' in screen.orientation) {
                                        screen.orientation.onchange = originalOnChange;
                                    }
                                }

                                function handleOrientationChange(event) {
                                    if (typeof originalOnChange === 'function') {
                                        originalOnChange.call(screen.orientation, event);
                                    }
                                    if (screen.orientation && screen.orientation.type && screen.orientation.type.startsWith('portrait')) {
                                        detachOrientationListeners();
                                        unlockOrientation();
                                    }
                                }

                                if (typeof screen.orientation.addEventListener === 'function') {
                                    screen.orientation.addEventListener('change', handleOrientationChange);
                                } else if ('onchange' in screen.orientation) {
                                    originalOnChange = screen.orientation.onchange;
                                    screen.orientation.onchange = handleOrientationChange;
                                }

                                const schedulePortraitCheck = (attempt = 0) => {
                                    if (!screen.orientation) {
                                        detachOrientationListeners();
                                        unlockOrientation();
                                        return;
                                    }
                                    if (screen.orientation.type && screen.orientation.type.startsWith('portrait')) {
                                        detachOrientationListeners();
                                        unlockOrientation();
                                    } else if (attempt < 5) {
                                        setTimeout(() => schedulePortraitCheck(attempt + 1), 500);
                                    }
                                };

                                schedulePortraitCheck();
                            } else {
                                unlockOrientation();
                            }
                        });
                    };

                    const updateChartDimensions = () => {
                        if (!chart2) {
                            return;
                        }
                        if (chartContainer2.classList.contains('fullscreen')) {
                            const availableWidth = Math.max(window.innerWidth - FULLSCREEN_PADDING, 320);
                            const availableHeight = Math.max(window.innerHeight - FULLSCREEN_PADDING, 320);
                            chart2.updateOptions({
                                chart: {
                                    width: availableWidth,
                                    height: availableHeight
                                }
                            }, false, true);
                        } else {
                            chart2.updateOptions({
                                chart: {
                                    width: '100%',
                                    height: 350
                                }
                            }, false, true);
                        }
                    };

                    const colors = ['#ff771d', '#4154f1', '#2eca6a'];
                    const defaultChartOptions = {
                        series: [
                            {
                                name: 'Pływalnia Kameralna',
                                data: {{ small_stat|safe }}
                            },
                            {
                                name: 'Pływalnia Sportowa',
                                data: {{ sport_stat|safe }}
                            },
                            {
                                name: 'Pływalnia Rodzinna',
                                data: {{ family_stat|safe }}
                            }
                        ],
                        chart: {
                            height: 350,
                            type: 'area',
                            background: document.body.classList.contains('dark-mode') ? '#1e2230' : 'white',
                            toolbar: {
                                show: false
                            },
                            events: {
                                mounted: function () {
                                    const loadingOverlay2 = chartContainer2.querySelector('#loadingOverlay');
                                    if (loadingOverlay2) {
                                        loadingOverlay2.style.display = 'none';
                                    }
                                }
                            }
                        },
                        markers: {
                            size: 2.5,
                            strokeWidth: 0,
                            strokeColors: 'transparent',
                            hover: {
                                size: 4,
                                sizeOffset: 0
                            }
                        },
                        colors: [colors[0], colors[1], colors[2]],
                        fill: {
                            type: "gradient",
                            gradient: {
                                shadeIntensity: 1,
                                inverseColors: false,
                                opacityFrom: 0.3,
                                opacityTo: 0.05,
                                stops: [0, 90, 100]
                            }
                        },
                        dataLabels: {
                            enabled: false
                        },
                        stroke: {
                            curve: 'smooth',
                            width: 2
                        },
                        yaxis: {
                            max: 160
                        },
                        xaxis: {
                            type: 'time',
                            tickAmount: 16,
                            tickInterval: 'hour',
                            categories: {{date_stat|safe}}
                        },
                        annotations: {
                            yaxis: [
                                {
                                    y: 30,
                                    borderColor: '#ff771d',
                                    borderWidth: 2
                                },
                                {
                                    y: 105,
                                    borderColor: '#4154f1',
                                    borderWidth: 2
                                },
                                {
                                    y: 150,
                                    borderColor: '#2eca6a',
                                    borderWidth: 2
                                }
                            ],
                            xaxis: [
                                {
                                    x: new Date().getTime(),
                                    borderColor: '#775DD0',
                                    borderWidth: 2
                                }
                            ]
                        },
                        tooltip: {
                            x: {
                                format: 'HH:mm'
                            },
                            y: {
                                formatter: function (value, { series, seriesIndex, dataPointIndex, w }) {
                                    let maxValue = '';
                                    if (w.config.series[seriesIndex].name === 'Pływalnia Kameralna') {
                                        maxValue = '/30';
                                    } else if (w.config.series[seriesIndex].name === 'Pływalnia Sportowa') {
                                        maxValue = '/105';
                                    } else if (w.config.series[seriesIndex].name === 'Pływalnia Rodzinna') {
                                        maxValue = '/150';
                                    } else if (w.config.series[seriesIndex].name === 'Lodowisko') {
                                        maxValue = '/300';
                                    }
                                    return value + maxValue;
                                }
                            }
                        }
                    };

                    chart2 = new ApexCharts(chartElement2, defaultChartOptions);
                    chart2.render();

                    // Update chart background when dark mode changes
                    const darkModeToggle = document.getElementById('darkModeToggle');
                    if (darkModeToggle) {
                        darkModeToggle.addEventListener('click', () => {
                            setTimeout(() => {
                                const isDarkMode = document.body.classList.contains('dark-mode');
                                chart2.updateOptions({
                                    chart: {
                                        background: isDarkMode ? '#1e2230' : 'white'
                                    }
                                });
                            }, 100);
                        });
                    }

                    const isMobile = () => {
                        const userAgentMatch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                        const pointerCoarse = window.matchMedia ? window.matchMedia('(pointer:coarse)').matches : false;
                        return userAgentMatch || (pointerCoarse && window.innerWidth <= 1024);
                    };

                    const updateFullscreenButtonVisibility = () => {
                        if (chartContainer2.classList.contains('fullscreen')) {
                            fullscreenBtn2.style.display = 'none';
                        } else {
                            fullscreenBtn2.style.display = isMobile() ? 'flex' : 'none';
                        }
                    };

                    updateFullscreenButtonVisibility();
                    window.addEventListener('resize', updateFullscreenButtonVisibility);

                    const finalizeFullscreenExit = () => {
                        if (!chartContainer2.classList.contains('fullscreen')) {
                            updateFullscreenButtonVisibility();
                            return;
                        }
                        isFallbackFullscreen = false;
                        chartElement2.classList.remove('fullscreen');
                        chartContainer2.classList.remove('fullscreen');

                        chartContainer2.style.opacity = '0';
                        chart2.destroy();
                        
                        // Update default options with current dark mode state
                        const currentBackground = document.body.classList.contains('dark-mode') ? '#1e2230' : 'white';
                        defaultChartOptions.chart.background = currentBackground;
                        
                        chart2 = new ApexCharts(chartElement2, defaultChartOptions);
                        chart2.render();

                        setTimeout(() => {
                            chartContainer2.style.opacity = '1';
                        }, 500);

                        if (orientationLocked) {
                            orientationLocked = false;
                            restorePortraitOrientation();
                        }

                        updateFullscreenButtonVisibility();
                    };

                    const handleFullscreenChange = () => {
                        const activeElement = getFullscreenElement();
                        if (activeElement === chartContainer2) {
                            isFallbackFullscreen = false;
                            if (!orientationLocked) {
                                tryLockOrientation(orientationPreferences.landscape).then((locked) => {
                                    orientationLocked = locked;
                                    if (!locked) {
                                        console.warn("Unable to lock screen orientation to landscape");
                                    }
                                });
                            }
                            updateFullscreenButtonVisibility();
                            updateChartDimensions();
                        } else if (!activeElement) {
                            finalizeFullscreenExit();
                        }
                    };

                    if (isMobile()) {
                        fullscreenBtn2.addEventListener("click", async () => {
                            fullscreenBtn2.disabled = true;
                            try {
                                const isAlreadyFullscreen = chartContainer2.classList.contains('fullscreen');
                                if (!isAlreadyFullscreen) {
                                    let usedNativeFullscreen = false;

                                    if (canUseNativeFullscreen(chartContainer2)) {
                                        try {
                                            await requestElementFullscreen(chartContainer2);
                                            await delay();
                                            usedNativeFullscreen = getFullscreenElement() === chartContainer2;
                                        } catch (requestError) {
                                            console.warn('Native fullscreen request failed, using fallback mode instead', requestError);
                                        }
                                    }

                                    isFallbackFullscreen = !usedNativeFullscreen;
                                    chartElement2.classList.add('fullscreen');
                                    chartContainer2.classList.add('fullscreen');

                                    updateChartDimensions();
                                    updateFullscreenButtonVisibility();
                                } else {
                                    const usingNativeFullscreen = !isFallbackFullscreen && getFullscreenElement() === chartContainer2;
                                    if (usingNativeFullscreen) {
                                        await exitElementFullscreen();
                                    } else {
                                        finalizeFullscreenExit();
                                    }
                                }
                            } catch (error) {
                                console.error("Error toggling fullscreen:", error);
                                finalizeFullscreenExit();
                            } finally {
                                fullscreenBtn2.disabled = false;
                            }
                        });

                        closeFullscreenBtn2.addEventListener("click", async () => {
                            const activeElement = getFullscreenElement();
                            if (!isFallbackFullscreen && activeElement === chartContainer2) {
                                await exitElementFullscreen();
                            } else if (chartContainer2.classList.contains('fullscreen')) {
                                finalizeFullscreenExit();
                            }
                        });
                    }

                    document.addEventListener("fullscreenchange", handleFullscreenChange);
                    document.addEventListener("webkitfullscreenchange", handleFullscreenChange);

                    window.addEventListener('resize', () => {
                        if (chartContainer2.classList.contains('fullscreen')) {
                            updateChartDimensions();
                        }
                    });

                    window.addEventListener('orientationchange', () => {
                        if (chartContainer2.classList.contains('fullscreen')) {
                            setTimeout(updateChartDimensions, 150);
                        }
                        updateFullscreenButtonVisibility();
                    });

                    chartElement2.addEventListener("contextmenu", (e) => {
                        e.preventDefault();
                        chart2.resetSeries();
                    });

                    function handleButtonClick(event) {
                        const loadingOverlay3 = chartContainer2.querySelector('#loadingOverlay');
                        if (loadingOverlay3) {
                            loadingOverlay3.style.display = 'flex';
                        }
                        
                        // Capture current series visibility state before update
                        const seriesVisibility = chart2.w.globals.collapsedSeriesIndices || [];
                        const hiddenSeries = new Set(seriesVisibility);
                        
                        const buttonId = event.target.id;
                        fetch(`/update_chart/${buttonId}`)
                            .then(response => response.json())
                            .then(data => {
                                const currentDate = data.today;
                                const todayElement = document.querySelector('#today');
                                if (todayElement) {
                                    todayElement.textContent = currentDate;
                                }
                                
                                // Update series first with animation enabled
                                chart2.updateSeries([
                                    {
                                        name: 'Kameralna',
                                        data: data.small_stat
                                    },
                                    {
                                        name: 'Sportowa',
                                        data: data.sport_stat
                                    },
                                    {
                                        name: 'Rodzinna',
                                        data: data.family_stat
                                    }
                                ], true);
                                
                                // Then update xaxis categories separately
                                chart2.updateOptions({
                                    xaxis: {
                                        type: 'time',
                                        tickAmount: 16,
                                        tickInterval: 'hour',
                                        categories: data.date_stat
                                    }
                                }, false, true);
                                
                                // Restore the hidden series state after a brief delay to allow chart to render
                                setTimeout(() => {
                                    hiddenSeries.forEach(seriesIndex => {
                                        chart2.hideSeries(chart2.w.config.series[seriesIndex].name);
                                    });
                                }, 50);

                                if (loadingOverlay3) {
                                    loadingOverlay3.style.display = 'none';
                                }
                            })
                            .catch((fetchError) => {
                                console.error('Error updating stats chart:', fetchError);
                                if (loadingOverlay3) {
                                    loadingOverlay3.style.display = 'none';
                                }
                            });
                    }

                    const buttons = document.querySelectorAll('.dropdown-item');
                    buttons.forEach(button => button.addEventListener('click', handleButtonClick));
                });
            </script>
        </div>
    </div>
</div>
{% endblock %}